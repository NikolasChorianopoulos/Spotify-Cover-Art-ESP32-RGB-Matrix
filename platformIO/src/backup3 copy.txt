#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <TJpg_Decoder.h>
#include <ESP32-HUB75-MatrixPanel-I2S-DMA.h>
#include <ArduinoJson.h>
#include "FS.h"
#include <LittleFS.h>
#include <Wire.h>
#include <SPI.h>
#include "SPIFFS.h"
#include <SD.h>

// WiFi Credentials
const char* ssid = "Crazy Science Duck";
const char* password = "6986821238";

// Spotify credentials
const char* client_id = "e57a0662b41a486ea2cdcfe94f457876";
const char* client_secret = "c8feb5189c2747eaa1327d74c8a9bf2c";
String refresh_token = "AQCBcHxTke_q-vYyvjTtu3Wwsu2hlr9GMvK1ueyqtnrLPnYXxBGAn3iIP6_4779ws65y_ehRtB_yjBaRiN4P3G27TizdD-4lHRKNY2y2HZQm6FZejR67RXPVc4blSxpc6zg"; // Obtain this from initial authorization
String access_token;

// Spotify API URLs
const char* token_url = "https://accounts.spotify.com/api/token";
const char* currently_playing_url = "https://api.spotify.com/v1/me/player/currently-playing";

// Function to refresh Spotify access token
void refreshAccessToken() {
    Serial.println("Refreshing access token...");
    HTTPClient http;
    http.begin(token_url);
    http.addHeader("Content-Type", "application/x-www-form-urlencoded");

    String requestBody = "grant_type=refresh_token&refresh_token=" + refresh_token +
                         "&client_id=" + client_id + "&client_secret=" + client_secret;

    int httpResponseCode = http.POST(requestBody);
    if (httpResponseCode == 200) {
        String response = http.getString();
        Serial.println("Access token refreshed");

        // Parse JSON to extract the new access token
        DynamicJsonDocument doc(1024);
        deserializeJson(doc, response);
        access_token = doc["access_token"].as<String>();
    } else {
        Serial.println("Failed to refresh token. HTTP code: " + String(httpResponseCode));
    }
    http.end();
}

// Function to get currently playing song's cover art
// Add a global variable to track the last imageUrl
String lastImageUrl = "";
String currentImageUrl;

void getCurrentlyPlaying() {
   
    HTTPClient http;
    http.begin(currently_playing_url);
    http.addHeader("Authorization", "Bearer " + access_token);

    int httpResponseCode = http.GET();
    if (httpResponseCode == 200) {
        String response = http.getString();

        // Parse the JSON response
        DynamicJsonDocument doc(16384); // Increased buffer size
        DeserializationError error = deserializeJson(doc, response);
        if (error) {
            Serial.print("JSON Deserialization failed: ");
            Serial.println(error.f_str());
            return;
        }

        // Extract the URL of the smallest album cover
        const char* imageUrl = doc["item"]["album"]["images"][2]["url"]; // Change the index if you want a larger image
        if (imageUrl) {
            String currentImageUrl = String(imageUrl);
            if (currentImageUrl != lastImageUrl) {
                lastImageUrl = currentImageUrl; // Update the last imageUrl
                Serial.println("Album Cover URL: " + lastImageUrl);
            }
            // No action needed if URL hasn't changed
        } else {
            Serial.println("Image URL not found in the response.");
        }
    } else if (httpResponseCode == 401) {
        Serial.println("Access token expired. Refreshing token...");
        refreshAccessToken(); // Token expired, refresh it
    } else {
        Serial.println("Failed to get currently playing song. HTTP code: " + String(httpResponseCode));
    }
    http.end();
}






MatrixPanel_I2S_DMA matrix;

void displaySetup() {
  // Matrix Panel Object
  HUB75_I2S_CFG mxconfig(
    64, // Width
    64, // Height
    1  // Number of chained panels
  );

    mxconfig.clkphase = false;

    //Pin Configuration, Initialize Matrix, Text Settings
    mxconfig.gpio.r1 = 25;
    mxconfig.gpio.g1 = 26;
    mxconfig.gpio.b1 = 27;
    mxconfig.gpio.r2 = 14;
    mxconfig.gpio.g2 = 12;
    mxconfig.gpio.b2 = 13;
    mxconfig.gpio.a = 23;
    mxconfig.gpio.b = 19;
    mxconfig.gpio.c = 5;
    mxconfig.gpio.d = 17;
    mxconfig.gpio.e = 32;
    mxconfig.gpio.lat = 4;
    mxconfig.gpio.oe = 15;
    mxconfig.gpio.clk = 16;
  
    
    matrix.begin(mxconfig);
    matrix.fillScreen(matrix.color565(0, 0, 0));
    matrix.setBrightness(150);
    

}

// Downloaded Image Buffer
uint8_t* jpgBuffer = nullptr;
size_t jpgSize = 0;

// Function to Render Pixels
// Function to Render Pixels
bool tftOutput(int16_t x, int16_t y, uint16_t w, uint16_t h, uint16_t* bitmap) {
  for (int16_t row = 0; row < h; row++) {
    for (int16_t col = 0; col < w; col++) {
      int16_t pixelX = x + col;
      int16_t pixelY = y + row;
      if (pixelX >= 0 && pixelY >= 0 && pixelX < PANEL_RES_X && pixelY < PANEL_RES_Y) {
        uint16_t color = bitmap[row * w + col];
        uint8_t r = (color >> 11) & 0x1F; // Extract 5-bit red
        uint8_t g = (color >> 5) & 0x3F;  // Extract 6-bit green
        uint8_t b = color & 0x1F;         // Extract 5-bit blue

        // Debug: Print RGB values
        if (r == 0 && g == 0 && b == 0) { // Only print for black pixels
          Serial.printf("Pixel (%d, %d): R=%d, G=%d, B=%d\n", pixelX, pixelY, r, g, b);
        }

        matrix.drawPixel(pixelX, pixelY, matrix.color565(r * 8, g * 4, b * 8));
      }
    }
  }
  return true;
}



// Download Image from URL
bool downloadImage() {
  
  HTTPClient http;
  http.begin(lastImageUrl);
  int httpCode = http.GET();

  if (httpCode == HTTP_CODE_OK) {
    jpgSize = http.getSize();
    jpgBuffer = (uint8_t*)malloc(jpgSize);
    if (!jpgBuffer) {
      Serial.println("Failed to allocate memory for image.");
      return false;
    }

    WiFiClient* stream = http.getStreamPtr();
    size_t bytesRead = 0;
    while (http.connected() && bytesRead < jpgSize) {
      size_t available = stream->available();
      if (available) {
        bytesRead += stream->readBytes(jpgBuffer + bytesRead, available);
      }
    }

    Serial.printf("HTTP GET Response Code: %d\n", httpCode);
    
    http.end();
    return true;
  }

  Serial.println("Failed to download image.");
  http.end();
  return false;
}




void setup() {
  Serial.begin(115200);

  // Connect to WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("WiFi connected.");

  displaySetup();

  // Initialize JPEG Decoder
  TJpgDec.setCallback(tftOutput);
  TJpgDec.setSwapBytes(false);

  // Refresh the token initially
    refreshAccessToken();

  

}

void loop() {
  getCurrentlyPlaying();  
  // Download and Display Image
  if (downloadImage()) {
    TJpgDec.drawJpg(0, 0, jpgBuffer, jpgSize);
    free(jpgBuffer);
  } else {
    Serial.println("Image display failed.");
  }
    Serial.printf("Expected JPEG Size: %d\n", jpgSize);
    if (jpgBuffer) {
        Serial.println("JPEG buffer successfully allocated.");
    } else {
        Serial.println("Failed to allocate JPEG buffer!");
    }
  delay(0);  
}
